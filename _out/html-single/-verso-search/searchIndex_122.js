window.docContents[122].resolve({"/#Notes-on-Mathlib--Verso--Docstrings-and-other-lean-code":{"id":"/#Notes-on-Mathlib--Verso--Docstrings-and-other-lean-code","header":"6.3. Docstrings and other lean code","context":"Notes on Mathlib\u0009Verso","contents":"One of the biggest advantages of Verso is that it can include docstrings from Lean code. This is done as follows:\n\n{docstring Lean.Parser.Tactic.apply}\n\n\napply e tries to match the current goal against the conclusion of e's type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.The apply tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n\nLean inline code as 2+2 is written like this:\n\n`2+2`\n\n\nLean code block are similar, but start with three backticks and the lean keyword.\n\nexample : 2 + 2 = 4 :=\n  by rfl\n\n\n#eval s!\"The answer is {2 + 2}\"\n\ntheorem bogus : False := by sorry\n\nexample := Nat.succ 2\n\n\nIllustrative examples are in expander boxes, as below:\n\nEven NumbersHere is a simple calculation.example: 2 + 2 = 4 := by rfl\n\n\n"}});